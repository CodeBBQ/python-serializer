import os
from glob import glob
from time import sleep

from .bcolors import FAIL, HEADER


class base_serializer:
    """Base class for serializer"""

    def __init__(
        self,
        rootpath: str = "/tmp",
        verbose: bool = False,
    ):
        self.path = f"{rootpath}"
        self.verbose = verbose

    def block(
        self,
        reason: str,
        processname: None | str = None,
        channel: str = "default",
    ):
        """
        The block function creates a file in the /tmp directory.
        The name of this file is generated by the generate_name function, which takes three arguments:
            reason: The reason for blocking (e.g., "sleeping", "working")
            processname: The name of the process that is blocking (e.g., "sleep", or "python3")
            channel: A string indicating what channel to block on (defaults to 'default')

        Parameters
        ----------
            self
                Access the attributes of the class
            reason:str
                Give a reason for the blocking
            processname:None|str=None
                Specify the process name
            channel:str="default"
                Specify the channel that is being blocked

        Returns
        -------

            None
        """
        try:
            path = self.generate_name(reason, processname, channel)
            self.reason = reason
            self.processname = processname
            self.channel = channel
            os.system(f"touch {path}")
            if self.verbose:
                print(HEADER(f"Blocking drive for {reason}ing due to {processname}"))
        except Exception as e:
            print(FAIL(e))

    def free(self, processname: str, channel: str):
        """
        The free function is used to free a channel from a process.
        It takes two arguments: the name of the process and the name of the channel.
        The function will then remove the file associated with that particular process.

        Parameters
        ----------
            self
                Access the class attributes
            processname:str
                Specify the name of the process that is being freed
            channel:str
                Specify the channel that we want to free

        Returns
        -------

            None

        """
        try:
            reasons = self.look()
            if not channel in reasons:
                raise ValueError("Channel not found")
            for reason in reasons[channel]:
                if reason[1] == processname:
                    path = self.generate_name(reason[0], processname, channel)
                    os.system(f"rm {path}")
                    if self.verbose:
                        print(
                            HEADER(
                                f"Freeing channel from {reason[1]}ing due to {processname} (removed {path})"
                            )
                        )
                    return None
            raise ValueError(f"Process {processname} not found in channel {channel}")
        except ValueError as e:
            print(FAIL(e))

    def test(
        self,
        channel: str = "default",
    ):
        """
        The test function checks if the channel is available.
        If it is, then it returns True. If not, then it prints out a message about what's blocking the channel and returns False.

        Parameters
        ----------
            self
                Access the class attributes
            channel:str="default"
                Specify which channel to check

        Returns
        -------

            A boolean value

        """

        reasons = self.look()
        if not channel in reasons:
            if self.verbose:
                print(HEADER(f"Channel {channel} is available." + " " * 40))
            return True
        else:
            if self.verbose:
                for _channel in reasons:
                    print(HEADER(f"Channel for {channel}:"))
                    for reason in reasons[_channel]:
                        print(HEADER(f"  - {reason[0]} by {reason[1]}"))
            else:
                msg = (
                    f"Channel {channel} blocked with {len(reasons[channel])} processes."
                )
                if hasattr(self, "wait"):
                    msg = f"{msg} Waiting {int(self.wait)} seconds."
                print(
                    HEADER(msg),
                    end="\r",
                )
            return False

    def look(self):
        """
        The look function is used to find the serializer files in the root directory.
        It returns a dictionary of lists, where each list contains tuples of (reason, processname) pairs.

        Parameters
        ----------
            self
                Access the attributes and methods of the class in a method

        Returns
        -------

            A dictionary with the keys being the serializers and their values being a list of tuples

        """

        reasons = glob(f"{self.path}/serializer*")
        reasons = [os.path.basename(reason) for reason in reasons]
        if self.verbose:
            print(HEADER(f"Found {reasons}."))
        blocks = base_serializer.interprete(reasons)
        interpretation = dict()
        for block in blocks:
            if block[0] not in interpretation:
                interpretation[block[0]] = list()
            interpretation[block[0]].append((block[1], block[2]))

        if self.verbose:
            print(HEADER(f"Interpreted {interpretation}."))
        return interpretation

    def generate_name(
        self,
        reason: str,
        processname: None | str = None,
        channel: str = "default",
    ):
        """
        The generate_name function generates a name for the serializer.
        It takes three arguments:
            1) reason: The reason for which the serializer is being created. This can be anything, but it should not contain - characters as these are used to separate different parts of the name.
            2) processname (optional): If this argument is provided, then it will be appended to the end of the generated name with a - character separating them. This can be useful for identifying which process is blocking the channel.
            3) channel (optional): This is the first element in the file name. Its default is 'default'.

        Parameters
        ----------
            self
                Access the class attributes
            reason:str
                Specify the reason for serialization
            processname:None|str=None
                Specify a processname
            channel:str="default"
                Specify the channel

        Returns
        -------

            The name of the file that will be created

        """

        if "-" in reason:
            raise ValueError("Reason must not contain -")
        if "-" in channel:
            raise ValueError("Channel must not contain -")
        if processname is not None:
            if "-" in processname:
                raise ValueError("Processname must not contain -")

        if processname is None:
            return f"{self.path}/serializer-{channel.lower()}-{reason.lower()}"
        else:
            return f"{self.path}/serializer-{channel.lower()}-{reason.lower()}-{processname.lower()}"

    @staticmethod
    def interprete(name):
        """
        The interprete function takes a string and returns a tuple of three elements:
        the channel, the reason, and the process name. The channel is the first part of
        the string (e.g., "stdout"). The reason is the second part of the string (e.g., "writing").
        If there is a process name encoded it is expected to be the last element in the string.

        Parameters
        ----------
            name
                Identify the process

        Returns
        -------

            A tuple with three values: the channel, the reason and a process name

        """

        if isinstance(name, (tuple, list)):
            return [base_serializer.interprete(n) for n in name]
        name = name.removeprefix("serializer-").split("-")
        if len(name) == 2:
            channel, reason, processname = name[0], name[1], None
        else:
            channel, reason, processname = name[0], name[1], name[2]
        return channel, reason, processname


class waiter(base_serializer):
    """Wait until a channel is available but do not block it."""

    def __init__(
        self,
        channel: None | str = "default",
        rootpath: str = "/tmp",
        verbose: bool = False,
        refresh: float = 1.0,
    ):
        """
        The waiter class inspect if the given channel is available and waits as long as it is not.
        It takes in a channel, rootpath, verbose and refresh as arguments.

        Parameters
        ----------
            self
                Refer to the object itself
            channel:None|str="default"
                Specify the channel that should be used
            rootpath:str="/tmp"
                Specify the path to a directory where the file will be stored
            verbose:bool=False
                Set the verbose parameter of the parent class
            refresh:float=1.0
                Set the refresh rate of the class

        Returns
        -------

            The object of the class

        Example
        -------
            # Process1: If channel drive is not blocked
            >>> with serializer('drive'):
            ...     sleep(10)
            ...     print("This process blocks drive.")
            Channel drive is available.
            This process blocks drive.

            # Process2: As process 1 is already running:
            >>> with waiter('drive'):
            ...     print("This must wait until process1 has finished and will not block drive for others.")
            Channel drive blocked with 1 processes. Waiting 10 seconds.


        """
        self.refresh = refresh
        self.wait = 0
        super().__init__(rootpath, verbose)
        while not self.test(channel.lower()):
            sleep(self.refresh)
            self.wait = self.wait + self.refresh

    def __enter__(self):
        return self

    def __exit__(self, *args):
        pass


class serializer(waiter):
    """Serializer class for waiting until a specific channel is available and blocking it for itself."""

    def __init__(
        self,
        reason: str,
        processname: None | str = None,
        channel: str = "default",
        rootpath: str = "/tmp",
        verbose: bool = False,
    ):
        """
        The serializer class inspect if the given channel is available and waits as long as it is not. If it starts, it blocks the channel for itself.
        It takes in a channel, rootpath, verbose and refresh as arguments.


        Parameters
        ----------
            self
                Refer to the object itself
            reason:str
                Specify the reason for which the process is blocked
            processname:None|str=None
                Specify the name of the process to be blocked
            channel:str="default"
                Specify the channel to use for logging
            rootpath:str="/tmp"
                Specify the path to a directory where the lock file will be created
            verbose:bool=False
                Set the verbose parameter of the super class

        Returns
        -------

            The object of the class

        Example
        -------
            # Process1: If channel drive is not blocked
            >>> with serializer('drive'):
            ...     sleep(10)
            ...     print("This process blocks drive.")
            Channel drive is available.
            This process blocks drive.

            # Process2: As process 1 is already running:
            >>> with serializer('drive'):
            ...     print("This must wait until process1 has finished and will block drive for others.")
            Channel drive blocked with 1 processes. Waiting 10 seconds.
        """

        self.reason = reason.lower()
        self.processname = processname.lower()
        self.channel = channel.lower()
        super().__init__(self.channel, rootpath, verbose)
        self.block(self.reason, self.processname, self.channel)

    def __exit__(self, *args):
        self.free(self.processname, self.channel)
